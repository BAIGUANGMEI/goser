// Type definitions matching the Go backend models
export interface ServiceInfo {
  name: string
  state: 'stopped' | 'starting' | 'running' | 'stopping' | 'failed'
  pid: number
  command: string
  args: string[]
  working_dir: string
  env: Record<string, string>
  auto_start: boolean
  auto_restart: boolean
  restart_count: number
  started_at: string | null
  stopped_at: string | null
  uptime: string
  cpu: number
  memory: number
  exit_code: number | null
  error: string
}

export interface DaemonStatus {
  running: boolean
  pid: number
  started_at: string
  uptime: string
  service_count: number
  running_count: number
  stopped_count: number
  failed_count: number
}

export interface LogEntry {
  service: string
  line: string
  stream: 'stdout' | 'stderr'
  timestamp: string
}

export interface ServiceConfig {
  name: string
  command: string
  args: string[]
  working_dir: string
  env: Record<string, string>
  auto_start: boolean
  auto_restart: boolean
  max_restarts: number
  restart_delay: number
  stop_signal: string
  stop_timeout: number
  log_file: string
  depends_on: string[]
}

// Wails runtime bindings - these are generated by Wails at build time
// In dev mode, we use a mock/proxy approach
declare global {
  interface Window {
    go: {
      main: {
        ServiceBridge: {
          GetDaemonStatus(): Promise<DaemonStatus>
          ListServices(): Promise<ServiceInfo[]>
          GetService(name: string): Promise<ServiceInfo>
          StartService(name: string): Promise<void>
          StopService(name: string): Promise<void>
          RestartService(name: string): Promise<void>
          CreateService(svc: ServiceConfig): Promise<void>
          UpdateService(name: string, svc: ServiceConfig): Promise<void>
          DeleteService(name: string): Promise<void>
          GetLogs(name: string, n: number): Promise<LogEntry[]>
          GetDaemonAddress(): Promise<string>
          StartDaemon(): Promise<void>
          StopDaemon(): Promise<void>
        }
      }
    }
  }
}

// API wrapper with fallback to HTTP for dev mode
const isWails = () => typeof window.go !== 'undefined'

const httpBase = 'http://127.0.0.1:9876'

async function httpGet<T>(path: string): Promise<T> {
  const resp = await fetch(`${httpBase}${path}`)
  const json = await resp.json()
  if (!json.success) throw new Error(json.error)
  return json.data as T
}

async function httpPost<T>(path: string, body?: unknown): Promise<T> {
  const resp = await fetch(`${httpBase}${path}`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: body ? JSON.stringify(body) : undefined
  })
  const json = await resp.json()
  if (!json.success) throw new Error(json.error)
  return json.data as T
}

async function httpPut<T>(path: string, body: unknown): Promise<T> {
  const resp = await fetch(`${httpBase}${path}`, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body)
  })
  const json = await resp.json()
  if (!json.success) throw new Error(json.error)
  return json.data as T
}

async function httpDelete<T>(path: string): Promise<T> {
  const resp = await fetch(`${httpBase}${path}`, { method: 'DELETE' })
  const json = await resp.json()
  if (!json.success) throw new Error(json.error)
  return json.data as T
}

export const api = {
  async getDaemonStatus(): Promise<DaemonStatus> {
    if (isWails()) return window.go.main.ServiceBridge.GetDaemonStatus()
    return httpGet<DaemonStatus>('/api/daemon/status')
  },

  async listServices(): Promise<ServiceInfo[]> {
    if (isWails()) return window.go.main.ServiceBridge.ListServices()
    return httpGet<ServiceInfo[]>('/api/services')
  },

  async getService(name: string): Promise<ServiceInfo> {
    if (isWails()) return window.go.main.ServiceBridge.GetService(name)
    return httpGet<ServiceInfo>(`/api/services/${name}`)
  },

  async startService(name: string): Promise<void> {
    if (isWails()) return window.go.main.ServiceBridge.StartService(name)
    await httpPost(`/api/services/${name}/start`)
  },

  async stopService(name: string): Promise<void> {
    if (isWails()) return window.go.main.ServiceBridge.StopService(name)
    await httpPost(`/api/services/${name}/stop`)
  },

  async restartService(name: string): Promise<void> {
    if (isWails()) return window.go.main.ServiceBridge.RestartService(name)
    await httpPost(`/api/services/${name}/restart`)
  },

  async createService(svc: ServiceConfig): Promise<void> {
    if (isWails()) return window.go.main.ServiceBridge.CreateService(svc)
    await httpPost('/api/services', svc)
  },

  async updateService(name: string, svc: ServiceConfig): Promise<void> {
    if (isWails()) return window.go.main.ServiceBridge.UpdateService(name, svc)
    await httpPut(`/api/services/${name}`, svc)
  },

  async deleteService(name: string): Promise<void> {
    if (isWails()) return window.go.main.ServiceBridge.DeleteService(name)
    await httpDelete(`/api/services/${name}`)
  },

  async getLogs(name: string, n: number = 100): Promise<LogEntry[]> {
    if (isWails()) return window.go.main.ServiceBridge.GetLogs(name, n)
    return httpGet<LogEntry[]>(`/api/services/${name}/logs?n=${n}`)
  },

  async startDaemon(): Promise<void> {
    if (isWails()) return window.go.main.ServiceBridge.StartDaemon()
    throw new Error('Start daemon is only available in the desktop app')
  },

  async stopDaemon(): Promise<void> {
    if (isWails()) return window.go.main.ServiceBridge.StopDaemon()
    throw new Error('Stop daemon is only available in the desktop app')
  },

  connectWebSocket(onEvent: (event: any) => void): WebSocket | null {
    try {
      const ws = new WebSocket(`ws://127.0.0.1:9876/ws`)
      ws.onmessage = (e) => {
        try {
          const event = JSON.parse(e.data)
          onEvent(event)
        } catch {}
      }
      ws.onerror = () => {}
      return ws
    } catch {
      return null
    }
  }
}
